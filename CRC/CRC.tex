
\chapter{CRC : Code de redondance cyclique}

    \section{Introduction}

        \paragraph{}
le CRC (Cyclic Redundancy Check), contrôle de redondance cyclique,
représente la principale méthode de détection d'erreurs utilisée dans les télécommunications et
consiste à protéger des blocs de données, appelés trames.
À chaque trame est associé un bloc de données, appelé code de contrôle (parfois CRC par abus de langage).
        \paragraph{}
On choisit un polynôme générateur, fixé et donc connu des deux entités qui se transmettent le message.
Grâce à celui ci, l'émetteur peut générer le code de contrôle qui est le reste de la division avec le message à envoyer.
Le récepteur divise ce qu'il a reçut, retrouve le message et sait si il y a eu un problème.
        \paragraph{}
Il existe plusieurs variantes du CRC selon le choix du polynôme : CRC 12, CRC 16, CRC CCIT v41, CRC 32, CRC ARPA.


    \section{Fiabilité}

        \paragraph{}
Deux erreurs peuvent être détectées à coup sur grâce au CRC 16.
Les erreurs détectées sont seulement celles où un nombre impairs de bit ont changé d'état ou
celles qui sont des suites de bit qui ont tous changés (rafales), de taille inférieur au
degré du polynôme.


    \section{Probabilité de détection}

        \paragraph{}
%Probabilité de détecter une erreur :
%\[  P(\text{Détection}) = P(\text{1 erreur}) \]
%\[  P(\text{Détection}) = {n\choose k}p^k(1-p)^{n-k} \]
%\[  P(\text{Détection}) \approx 74\% \text{ avec } P(\text{Erreur}) = 10\% \]

% vers 99% apparement ;)


    \section{Rendement}

        \paragraph{}
Le rendement de ce code est dépendant de la taille du message :
\[  Rendement = \frac{\text{Taille du message}}{\text{Taille du message} + \text{Degré du polynôme}} \]
        \paragraph{}
Pour notre message d'exemple, un message de seulement 7 bit de longueur, un codage avec du CRC 16 donne un rendement très médiocre :
\[  Rendement = \frac{7}{7 + 16} \approx 30\%  \]
        \paragraph{}
Cependant avec un message de taille plus importante comme par exemple un message de 128 bit avec du CRC 16 le rendement devient excellent :
\[  Rendement = \frac{128}{128 + 16} \approx 89\%  \]


    \section{Exemple pratique}
           \lstset{
                language=bash, basicstyle=\ttfamily\small, columns=flexible,
                tabsize=2, extendedchars=true, showspaces=false,
                showstringspaces=false, numbers=left, numberstyle=\tiny,
                breaklines=true, breakautoindent=true, captionpos=b
            }

    \begin{lstlisting}
>> perl envoiNoise.pl 9001 127.0.0.1:9000

 -> envoi du caractere : o

 -> nombre de caracteres envoyes : 100000

    \end{lstlisting}

    \begin{lstlisting}
>> perl receptionNoise.pl 9000 127.0.0.1:9001

 -> nombre de receptions : 100000
 -> nombre de receptions supposees bonnes : 7557
 -> nombre de vrais bons caracteres : 7301
 -> nombre d'erreurs au total : 92699
 -> nombre d'erreurs detectees : 92443
 -> nombre d'erreurs non detectees : 256
 -> fiabilitee de l'envoi/reception : 7.301%
 -> fiabilitee de detection d'erreur : 99.7238373660989%

    \end{lstlisting}
