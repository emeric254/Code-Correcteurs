\part{Code de détection}


    \chapter{VRC : Bit de parité}

        \section{Introduction}

            \paragraph{}
                le VRC (Vertical Redundancy Check), plus connu sous le nom de bit de parité,
                est simplement le rajout d'un bit en fin de message
                pour assurer la parité du message.

        \newpage

        \section{Détails}

            \subsection{Fonctionnement}

                \paragraph{}
                    Ce dernier bit la valeur nécessaire pour assurer un nombre pair de bit à 1 dans le message final.
                    Il est donc à 0 pour un nombre pair de bit à 1 dans le message de départ, ou est à 1.

            \subsection{Erreur(s) détectée(s)}

                \paragraph{}
                    Une seule erreur peut être détectée a coup sur.
                    Cependant les erreurs détectée sont celles ou un nombre impairs de bit ont changé d'état.

            \subsection{Probabilité de détection}

                \paragraph{}
                    Probabilité de détecter une erreur :
                    \[  P(D\acute{e}tection) = P(1 erreur) + P(3 erreurs) + P(5 erreurs) + P(7 erreurs) \]
                    \[  P(D\acute{e}tection) = {n\choose k}p^k(1-p)^{n-k} + {n\choose k} + {n\choose k} + {n\choose k} \]
                    Pour une probabilité d'erreur de 10\% :
                    \[  P(D\acute{e}tection) \approx 0.74\% \]

            \subsection{Rendement}

                \paragraph{}
                    Le rendement de ce code est très bon :
                    \[  Rendement = \frac{taille du message}{taille du message+1} \]
                    Pour un message sur 7 bits (un caractère en UTF-7 par exemple) :
                    \[  Rendement = \frac{7}{7+1} = 87.5\% \]



    \chapter{CRC : Code de redondance cyclique}

        \section{Introduction}

            \paragraph{}
                le CRC (Cyclic Redundancy Check), contrôle de redondance cyclique,
                est une évaluation pré et post envoi du message.

        \newpage

        \section{Détails}

            \subsection{Fonctionnement}

                \paragraph{}
                    On choisit un polynôme générateur qui est donc fixé et connu des deux entités qui se transmettent le message.
                    Grâce a celui ci, l'émetteur peut générer un checksum (somme de contrôle) qui est le reste
                    de la division le message a envoyer et le polynôme. Il est ensuite concaténer au message.
                    Le receveur divise ce qu'il a reçut par le polynôme et retrouve donc le message ou
                    sait si il y a eu un problème.

                \paragraph{}
                    Il existe plusieurs variante du CRC selon le choix du polynôme.
                    CRC 12, CRC 16, CRC CCIT v41, CRC 32, CRC ARPA

            \subsection{Erreur(s) détectée(s)}

                \paragraph{}
                    Deux erreurs peuvent être détectées grâce au CRC 16.
                    Cependant les erreurs détectées sont celles ou un nombre impairs de bit ont changé d'état ou
                    celles qui sont des suites de bit qui ont tous changés (rafales) de taille inférieur au
                    degré du polynôme.

            \subsection{Probabilité de détection}

                \paragraph{}
                    Probabilité de détecter une erreur :
                    \[  P(D\acute{e}tection) = P(1 erreur) + P(3 erreurs) + P(5 erreurs) + P(7 erreurs) \]
                    \[  + P(9 erreurs) + P(11 erreurs) + P(13 erreurs) + P(15 erreurs) + ...XXX... \]
                    Pour une probabilité d'erreur de 10\% :
                    \[  P(D\acute{e}tection) =  0.XXX\% \]

            \subsection{Rendement}

                \paragraph{}
                    Le rendement de ce code est dépendant de la taille du message :
                    \[  Rendement = \frac{taille du message}{taille du message + Degr\acute{e} du polyn\hat{o}me} \]



    \chapter{Code de répétition}



    \chapter{Hachage}

